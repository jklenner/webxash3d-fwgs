<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.png" type="image/png" />
  <script type="module" src="/main.ts"></script>
  <title>Loading</title>
  <style>
    :root { --brand:#1B3F5A; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background-color: var(--brand);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #fff;
    }

    /* Background canvas */
    #bg { width: 100vw; height: 100vh; position: fixed; inset: 0; z-index: 1; pointer-events: none; display: block; opacity: 1; transition: opacity .3s ease; }
    #canvas { width: 100vw; height: 100vh; position: fixed; inset: 0; z-index: 6; display: block; opacity: 0; pointer-events: none; transition: opacity .3s ease; }

    /* Centered logo */
    #logo {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 9; /* above UI, below modal (10) */
      aspect-ratio: 1 / 1;
      object-fit: cover;
      user-select: none;
      -webkit-user-drag: none;
      border-radius: 50%; /* perfectly round */
      pointer-events: auto; /* ensure clicks are captured */
    }
    /* one-time spin animation */
    @keyframes spinOnce {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to   { transform: translate(-50%, -50%) rotate(-360deg); }
    }
    .spin-once { animation: spinOnce 0.8s ease-out 1; }

    /* fade-out used by main.ts after loading */
    @keyframes pulsate-end {
      0%   { transform: translate(-50%, -50%) scale(0.75); opacity: 0.87; }
      100% { transform: translate(-50%, -50%) scale(1);     opacity: 0; }
    }

    /* Bottom form */
    form#form {
      margin: 0; padding: 16px; position: fixed; left: 0; right: 0; bottom: 0; z-index: 4;
      display: flex; justify-content: space-between; align-items: center; color: white; gap: 12px;
      background: linear-gradient(to top, rgba(0,0,0,0.35), rgba(0,0,0,0));
    }
    #form label { display: flex; align-items: center; gap: 8px; font-weight: 600; }
    #form input{
      background: rgba(255,255,255,0.08);
      border: 1px solid #444;
      padding: 8px 10px;
      border-radius: 8px;
      color: white;
      min-width: 200px;
    }
    #form button{
      background: transparent; border: 1px solid #cfd8ea; color: white; padding: 8px 14px; border-radius: 10px; cursor: pointer;
    }
    #form button:hover{ border-color: #fff; }
    #form button[disabled]{ opacity: .5; cursor: not-allowed; border-color: #666; }

    /* Warning text */
    #warning {
      position: fixed; left: 0; right: 0; bottom: 56px; z-index: 4; text-align: center; color: #ff6b6b;
      opacity: 0; transition: opacity .4s ease;
      text-shadow: 0 1px 2px rgba(0,0,0,.35);
    }

    /* Modal */
    body.modal-open { overflow: hidden; }
    .modal {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.6); z-index: 10; opacity: 0; pointer-events: none; transition: opacity .2s ease;
    }
    .modal.show { opacity: 1; pointer-events: auto; }
    .dialog {
      width: min(92vw, 460px);
      background: #0b1220; border: 1px solid #263042; border-radius: 14px; padding: 12px; color: #fff;
      box-shadow: 0 20px 60px rgba(0,0,0,.5);
    }
    .dialog-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 6px; }
    .dialog-title { font-weight: 700; letter-spacing: .2px; }
    .icon-btn { background: transparent; color: #fff; border: 1px solid #3a4b68; border-radius: 8px; padding: 4px 10px; cursor: pointer; }
    .icon-btn:hover { border-color: #5f7aa7; }
    .hint { text-align: center; opacity: .85; margin: 6px 0 8px; font-size: 12px; }

    /* Game canvas — fixed game pixel size, no scaling */
    #flappy-canvas { display: block; width: 400px; height: 600px; background: #fff; border-radius: 10px; margin: 0 auto; }
    /* CS image above the logo (original size) */
    #cs {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 2; /* below logo so logo stays clickable */
      transform: scale(0.5);
      transform-origin: bottom right;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none; /* never block clicks */
    }
</style>
</head>
<body>
  <!-- Background canvas -->
  <canvas id="bg"></canvas>
  <canvas id="canvas"></canvas>

  <!-- Center logo (no pulse). Easter egg: 5 clicks spin, 10 total open game -->
  <img id="cs" alt="CS" src="cs.png" />
  <img id="logo" alt="Logo" src="logo.png" />

  <!-- Bottom form -->
  <form id="form" autocomplete="off">
    <label>
      Player name
      <input id="username" type="text" required autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" />
    </label>
    <button type="submit" id="startBtn" disabled>Start</button>
  </form>
  <p id="warning">If it's not starting, try to enable microphone and refresh</p>

  <!-- Mini‑game modal -->
  <div id="gameModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="dialog">
      <canvas id="flappy-canvas" width="400" height="600" aria-label="Flappy game"></canvas>
    </div>
  </div>

  <script type="module">
(() => {
  // ===== Element references =====
  const logoEl = document.getElementById('logo');
  const gameModal = document.getElementById('gameModal');
  const formEl = document.getElementById('form');
  const usernameInput = document.getElementById('username');
  const warningEl = document.getElementById('warning');
  const bgCanvas = document.getElementById('bg');
  const engineCanvas = document.getElementById('canvas');
  const startBtn = document.getElementById('startBtn');
  const csImg = document.getElementById('cs');

  let canStart = false; // enabled only after main.ts triggers pulsate-end

  // ===== Start gating helpers =====
  function lockStart(){ canStart = false; if (startBtn){ startBtn.disabled = true; startBtn.setAttribute('aria-disabled','true'); } }
  function enableStart(){ canStart = true; if (startBtn){ startBtn.disabled = false; startBtn.removeAttribute('aria-disabled'); } }
  lockStart();
  // bfcache restore safety
  window.addEventListener('pageshow', () => { lockStart(); });

  // ===== Background starfield (persists until Start) =====
  const bgCtx = bgCanvas.getContext('2d');
  function resize(){ const dpr = window.devicePixelRatio || 1; bgCanvas.width = innerWidth*dpr; bgCanvas.height = innerHeight*dpr; bgCtx.setTransform(dpr,0,0,dpr,0,0); }
  addEventListener('resize', resize); resize();
  const stars = Array.from({length:140}, () => ({ x: Math.random()*innerWidth, y: Math.random()*innerHeight, r: Math.random()*1.6+0.2, vx:(Math.random()-0.5)*0.35, vy:(Math.random()-0.5)*0.35 }));
  let bgActive = true;
  function wrap(p){ if(p.x<0)p.x+=innerWidth; if(p.x>innerWidth)p.x-=innerWidth; if(p.y<0)p.y+=innerHeight; if(p.y>innerHeight)p.y-=innerHeight; }
  function starLoop(){ if(!bgActive) return; bgCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim()||'#1B3F5A'; bgCtx.fillRect(0,0,innerWidth,innerHeight); bgCtx.globalAlpha=0.95; bgCtx.beginPath(); for(const s of stars){ s.x+=s.vx; s.y+=s.vy; wrap(s); bgCtx.moveTo(s.x,s.y); bgCtx.arc(s.x,s.y,s.r,0,Math.PI*2); } bgCtx.fillStyle='white'; bgCtx.fill(); bgCtx.globalAlpha=1; requestAnimationFrame(starLoop); }
  starLoop();
  function fadeOutBg(){ if(!bgActive) return; bgActive=false; if(bgCanvas){ bgCanvas.style.opacity='0'; setTimeout(()=>{ if(bgCanvas) bgCanvas.style.display='none'; }, 450); } }

  // ===== Modal controls =====
  let flappyCtl = null;
  function openGame(){ if(!gameModal) return; gameModal.classList.add('show'); document.body.classList.add('modal-open'); flappyCtl = window.startFlappyBird('flappy-canvas'); }
  function closeGame(){ if(!gameModal) return; gameModal.classList.remove('show'); document.body.classList.remove('modal-open'); if(flappyCtl && typeof flappyCtl.stop==='function'){ try{ flappyCtl.stop(); }catch(_){} } flappyCtl=null; }
  gameModal?.addEventListener('click', (e)=>{ if(e.target===gameModal) closeGame(); });
  addEventListener('keydown', (e)=>{ if(e.key==='Escape' && gameModal?.classList.contains('show')) closeGame(); });

  // ===== Loading finished detection (robust) =====
  let readyFlag = false;
  function markReady(){
    if (readyFlag) return;
    readyFlag = true;
    closeGame();
    enableStart();
  }
  // Events path (if the CSS animation actually runs)
  logoEl?.addEventListener('animationstart', (e) => { if (e.animationName === 'pulsate-end') markReady(); });
  logoEl?.addEventListener('animationend',   (e) => { if (e.animationName === 'pulsate-end') { markReady(); logoEl.style.display='none'; } });
  // MutationObserver path — catches direct style changes from main.ts even with 0s duration
  if (logoEl) {
    const mo = new MutationObserver(() => {
      const n = logoEl.style.animationName || getComputedStyle(logoEl).animationName;
      if (n && n.includes('pulsate-end')) markReady();
    });
    mo.observe(logoEl, { attributes: true, attributeFilter: ['style'] });
  }

  // ===== Logo Easter egg: 5 clicks spin, 10 clicks open game =====
  let logoClickCount = 0;
  function onLogoClick(){
    logoClickCount++;
    if (logoClickCount === 5) {
      logoEl.classList.add('spin-once');
      logoEl.addEventListener('animationend', () => logoEl.classList.remove('spin-once'), { once: true });
    } else if (logoClickCount === 10) {
      logoClickCount = 0; openGame();
    }
  }
  logoEl?.addEventListener('click', onLogoClick);

  // ===== Form submit (reveals engine canvas and fades bg) =====
  formEl?.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!canStart) return;
    const name = (usernameInput && usernameInput.value || '').trim();
    if (!name) { usernameInput?.focus(); return; }
    formEl.style.display = 'none';
    if (engineCanvas){ engineCanvas.style.opacity='1'; engineCanvas.style.pointerEvents='auto'; }
    fadeOutBg();
    if (csImg){ if(!csImg.style.transition) csImg.style.transition='opacity .3s ease'; csImg.style.opacity='0'; setTimeout(()=>{ csImg.style.display='none'; }, 350); }
    try { const stream = await navigator.mediaDevices.getUserMedia({ audio:true }); stream.getTracks().forEach(t=>t.stop()); warningEl.style.opacity=0; } catch(_) { warningEl.style.opacity=1; }
  });

  // ===== Flappy Bird (time-based, robust image handling) =====
  window.startFlappyBird = function(canvasId){
    const canvas = document.getElementById(canvasId);
    if (!canvas) return { stop(){} };
    const ctx = canvas.getContext('2d');
    canvas.width = 400; canvas.height = 600;

    const birdImage = new Image();
    let imgReady = false;
    birdImage.onload = () => { imgReady = true; start(); };
    birdImage.onerror = () => { imgReady = false; start(); };
    const logoElForBird = document.getElementById('logo');
    const birdSrc = (logoElForBird && logoElForBird.src) ? logoElForBird.src : 'logo.png';
    birdImage.src = birdSrc;

    let gameState='start', score=0, pipes=[];
    const FIXED_DT=1/60, PIPE_SPEED=120, PIPE_SPAWN_INTERVAL=1.5, SPIN_DURATION=0.5, GAME_OVER_LOCKOUT=1;
    const pipeWidth=60, pipeGap=150;
    let timeSinceLastPipe=0, spinTimerSec=0, gameOverTimerSec=0;
    let highScore = parseInt(localStorage.getItem('flappyBirdHighScore') || '0');
    const bird = { x:50, y:150, width:40, height:40, velocity:0, gravity:1800, jumpForce:-480 };

    function drawRoundedRect(c,x,y,w,h,r,fill,stroke){ c.beginPath(); c.moveTo(x+r,y); c.lineTo(x+w-r,y); c.quadraticCurveTo(x+w,y,x+w,y+r); c.lineTo(x+w,y+h-r); c.quadraticCurveTo(x+w,y+h,x+w-r,y+h); c.lineTo(x+r,y+h); c.quadraticCurveTo(x,y+h,x,y+h-r); c.lineTo(x,y+r); c.quadraticCurveTo(x,y,x+r,y); c.closePath(); c.fillStyle=fill; c.fill(); c.lineWidth=2; c.strokeStyle=stroke; c.stroke(); }
    function clamp(v,min,max){ return Math.max(min, Math.min(v,max)); }
    function circleRectCollision(cx,cy,r,rx,ry,rw,rh){ const cx2=clamp(cx,rx,rx+rw); const cy2=clamp(cy,ry,ry+rh); const dx=cx-cx2, dy=cy-cy2; return (dx*dx+dy*dy) < r*r; }

    function resetGame(){ bird.y=150; bird.velocity=0; pipes=[]; score=0; timeSinceLastPipe=0; spinTimerSec=0; gameOverTimerSec=0; }
    function triggerGameOver(){ if (gameState!=='gameOver'){ gameState='gameOver'; gameOverTimerSec=GAME_OVER_LOCKOUT; if (score>highScore){ highScore=score; localStorage.setItem('flappyBirdHighScore', String(highScore)); } } }

    const onCanvasClick = () => { if (gameState==='start'){ gameState='playing'; resetGame(); } else if (gameState==='playing'){ bird.velocity = bird.jumpForce; } else if (gameState==='gameOver' && gameOverTimerSec<=0){ gameState='playing'; resetGame(); } };
    const onKeyDown = (e) => { if (e.code==='Space'){ e.preventDefault(); onCanvasClick(); } };
    canvas.addEventListener('click', onCanvasClick);
    document.addEventListener('keydown', onKeyDown);

    function update(dt){
      if (gameState==='gameOver' && gameOverTimerSec>0) gameOverTimerSec = Math.max(0, gameOverTimerSec - dt);
      if (spinTimerSec>0) spinTimerSec = Math.max(0, spinTimerSec - dt);
      if (gameState!=='playing') return;
      bird.velocity += bird.gravity * dt; bird.y += bird.velocity * dt;
      timeSinceLastPipe += dt;
      while (timeSinceLastPipe >= PIPE_SPAWN_INTERVAL){ timeSinceLastPipe -= PIPE_SPAWN_INTERVAL; const gapY = Math.random() * (canvas.height - pipeGap - 40) + 20; pipes.push({ x:canvas.width, gapY, width:pipeWidth, gap:pipeGap, passed:false }); }
      for (let i=0;i<pipes.length;i++){ const p = pipes[i]; p.x -= PIPE_SPEED * dt; if (!p.passed && p.x + p.width < bird.x){ score++; p.passed = true; spinTimerSec = SPIN_DURATION; } const cx = bird.x + bird.width/2, cy = bird.y + bird.height/2, r = bird.width/2; if (circleRectCollision(cx,cy,r,p.x,0,p.width,p.gapY) || circleRectCollision(cx,cy,r,p.x,p.gapY+p.gap,p.width,canvas.height-(p.gapY+p.gap))) triggerGameOver(); }
      pipes = pipes.filter(p => p.x + p.width > 0);
      if (bird.y + bird.height > canvas.height || bird.y < 0) triggerGameOver();
    }

    function draw(){
      ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0,0,canvas.width,canvas.height);
      if (gameState==='playing' || gameState==='gameOver'){
        ctx.fillStyle = '#1B3F5A';
        pipes.forEach(p => { ctx.fillRect(p.x,0,p.width,p.gapY); ctx.fillRect(p.x,p.gapY+p.gap,p.width,canvas.height-(p.gapY+p.gap)); });
      }
      ctx.save();
      let angle = 0; if (spinTimerSec>0){ const progress = 1 - (spinTimerSec / SPIN_DURATION); angle = progress * Math.PI * 2; }
      ctx.translate(bird.x + bird.width/2, bird.y + bird.height/2);
      ctx.beginPath(); ctx.arc(0,0,bird.width/2,0,Math.PI*2); ctx.closePath(); ctx.clip();
      ctx.rotate(-angle);
      if (imgReady) { ctx.drawImage(birdImage, -bird.width/2, -bird.height/2, bird.width, bird.height); }
      else { ctx.fillStyle = '#1B3F5A'; ctx.beginPath(); ctx.arc(0,0,bird.width/2,0,Math.PI*2); ctx.fill(); ctx.lineWidth=3; ctx.strokeStyle='#0a2133'; ctx.stroke(); }
      ctx.restore();

      ctx.font = '20px Arial'; ctx.textAlign = 'left'; let pad = 4; const s1='Score: '+score, s2='High Score: '+highScore; const w=Math.max(ctx.measureText(s1).width, ctx.measureText(s2).width)+pad*2; drawRoundedRect(ctx,5,5,w,50,8,'#fff','#1B3F5A'); ctx.fillStyle='#1B3F5A'; ctx.fillText(s1,5+pad,25); ctx.fillText(s2,5+pad,45);

      if (gameState==='start'){
        ctx.font='24px Arial'; ctx.textAlign='center'; const l1='Press Space', l2='or Click to Start'; pad=10; const bw=Math.max(ctx.measureText(l1).width, ctx.measureText(l2).width)+pad*2; const bh=70; const bx=(canvas.width-bw)/2; const by=canvas.height/2-bh/2; drawRoundedRect(ctx,bx,by,bw,bh,8,'#fff','#1B3F5A'); ctx.fillStyle='#1B3F5A'; ctx.fillText(l1, canvas.width/2, by+30); ctx.fillText(l2, canvas.width/2, by+55);
      } else if (gameState==='gameOver'){
        const l0='Game Over', lS='Score: '+score, lR='Click or Press Space to Restart'; pad=10; ctx.font='40px Arial'; ctx.textAlign='center'; const gw=ctx.measureText(l0).width; ctx.font='24px Arial'; const sw=ctx.measureText(lS).width; const rw=ctx.measureText(lR).width; const bw=Math.max(gw,sw,rw)+pad*2; const bh=150; const bx=(canvas.width-bw)/2; const by=canvas.height/2-bh/2; drawRoundedRect(ctx,bx,by,bw,bh,8,'#fff','#1B3F5A'); ctx.fillStyle='#1B3F5A'; ctx.font='40px Arial'; ctx.fillText(l0, canvas.width/2, by+45); ctx.font='24px Arial'; ctx.fillText(lS, canvas.width/2, by+80); if (gameOverTimerSec<=0){ ctx.font='20px Arial'; ctx.fillText(lR, canvas.width/2, by+120); }
      }
    }

    let last=null, acc=0, rafId=null, running=true;
    function gameLoop(t){ if(!running) return; const now=t/1000; if(last===null) last=now; let dt=now-last; if(dt>0.25) dt=0.25; last=now; acc+=dt; while(acc>=FIXED_DT){ update(FIXED_DT); acc-=FIXED_DT; } draw(); rafId=requestAnimationFrame(gameLoop); }
    function start(){ if(running && rafId===null) rafId=requestAnimationFrame(gameLoop); }
    function stop(){ running=false; if(rafId) cancelAnimationFrame(rafId); rafId=null; canvas.removeEventListener('click', onCanvasClick); document.removeEventListener('keydown', onKeyDown); }

    return { stop };
  };

  // ===== Self-tests (non-blocking) =====
  try {
    console.assert(document.getElementById('bg'), '#bg exists');
    console.assert(document.getElementById('canvas'), '#canvas exists');
    console.assert(getComputedStyle(document.getElementById('canvas')).opacity === '0', '#canvas hidden until Start');
    console.assert(typeof window.startFlappyBird === 'function', 'startFlappyBird defined');
  } catch(e) { console.warn('Self-tests warning:', e); }
})();
</script>
</body>
</html>

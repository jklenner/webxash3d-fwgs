<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/favicon.png" type="image/png" />

  <!-- Early audio master-volume shim (wraps WebAudio and exposes window.__setMasterVolume) -->
  <script>
  (function(){
    try{
      var KEY='audioVolume';
      var saved=parseFloat(localStorage.getItem(KEY)||'1'); if(!isFinite(saved)) saved=1;
      saved=Math.min(1,Math.max(0,saved));
      window.__masterVolume=saved;

      var OriginalAC=window.AudioContext||window.webkitAudioContext;
      if(!OriginalAC) return;

      function WrappedAC(){
        var ctx;
        try{ ctx = arguments.length ? new OriginalAC(arguments[0]) : new OriginalAC(); }
        catch(e){ ctx = new OriginalAC(); }
        try{
          ctx.__realDestination = ctx.destination;
          var g = ctx.createGain();
          g.gain.value = window.__masterVolume;
          g.connect(ctx.__realDestination);
          ctx.__masterGain = g;

          if(!AudioNode.prototype.__mvPatched){
            AudioNode.prototype.__mvPatched = true;
            var _origConnect = AudioNode.prototype.connect;
            AudioNode.prototype.connect = function(dest){
              try{
                if(dest instanceof (window.AudioDestinationNode||Function) && this.context && this.context.__masterGain){
                  var args = Array.prototype.slice.call(arguments);
                  args[0] = this.context.__masterGain;
                  return _origConnect.apply(this, args);
                }
              }catch(e){}
              return _origConnect.apply(this, arguments);
            };
          }
        }catch(e){}
        (window.__audioCtxs||(window.__audioCtxs=[])).push(ctx);
        return ctx;
      }
      WrappedAC.prototype = OriginalAC.prototype;
      try{
        if(window.AudioContext) window.AudioContext = WrappedAC;
        if(window.webkitAudioContext) window.webkitAudioContext = WrappedAC;
      }catch(e){}

      window.__setMasterVolume = function(v){
        var vol = Math.min(1,Math.max(0,Number(v)));
        if(!isFinite(vol)) return;
        window.__masterVolume = vol;
        try{ localStorage.setItem(KEY,String(vol)); }catch(e){}
        var arr = window.__audioCtxs||[];
        for(var i=0;i<arr.length;i++){
          try{ if(arr[i].__masterGain) arr[i].__masterGain.gain.value = vol; }catch(e){}
        }
      };
    }catch(e){}
  })();
  </script>

  <script type="module" src="/main.ts"></script>
  <title>Loading</title>
  <style>
    :root { --brand:#1B3F5A; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background-color: var(--brand);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: #fff;
    }

    /* Background canvases */
    #bg { width: 100vw; height: 100vh; position: fixed; inset: 0; z-index: 1; pointer-events: auto; display: block; opacity: 1; transition: opacity .3s ease; cursor: auto; }
    #canvas { width: 100vw; height: 100vh; position: fixed; inset: 0; z-index: 6; display: block; opacity: 0; pointer-events: none; transition: opacity .3s ease; image-rendering: high-quality; will-change: transform; contain: strict;}

    /* Invisible DOM logo (readiness detection via main.ts animation) */
    #logo {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 9; aspect-ratio: 1 / 1; object-fit: cover; user-select: none; -webkit-user-drag: none;
      border-radius: 50%; opacity: 0; pointer-events: none;
    }
    @keyframes pulsate-end {
      0%   { transform: translate(-50%, -50%) scale(0.75); opacity: 0.87; }
      100% { transform: translate(-50%, -50%) scale(1);     opacity: 0; }
    }

    /* Bottom form */
    form#form {
      margin: 0; padding: 20px 26px; position: fixed; left: 0; right: 0; bottom: 0; z-index: 4;
      display: flex; justify-content: space-between; align-items: center; color: white; gap: 12px;
      background: linear-gradient(to top, rgba(0,0,0,0.35), rgba(0,0,0,0));
    }
    #form label { display: flex; align-items: center; gap: 8px; font-weight: 600; }
    #form input{
      background: rgba(255,255,255,0.08); border: 1px solid #444; padding: 8px 10px; border-radius: 8px; color: white; min-width: 200px;
    }

    /* CTA slot (progress OR Start) */
    #cta { display: flex; align-items: center; justify-content: center; min-width: 50px; min-height: 50px; }
    #startBtn{
      display: none; /* shown when loading is done */
      background: transparent; border: 1px solid #cfd8ea; color: white; padding: 8px 14px; border-radius: 10px; cursor: pointer;
    }
    #startBtn:hover{ border-color: #fff; }
    #startBtn[disabled]{ opacity: .5; cursor: not-allowed; border-color: #666; }

    /* Circular progress (50x50) */
    #progressContainer { width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; }
    #progressContainer[hidden]{ display:none; }
    .circular { width: 50px; height: 50px; display:block; }
    .circular .bg, .circular .bar { fill: none; stroke-width: 3; }
    .circular .bg { stroke: rgba(255,255,255,.25); }
    .circular .bar {
      stroke: #fff; stroke-linecap: round;
      transform: rotate(-90deg); transform-origin: 50% 50%;
      stroke-dasharray: 100 100; stroke-dashoffset: 100;
      transition: stroke-dashoffset .2s ease;
    }
    .circular.spin { animation: rot 1s linear infinite; }
    @keyframes rot { to { transform: rotate(360deg); } }

    /* Warning */
    #warning {
      position: fixed; left: 0; right: 0; bottom: 56px; z-index: 4; text-align: center; color: #ff6b6b;
      opacity: 0; transition: opacity .4s ease; text-shadow: 0 1px 2px rgba(0,0,0,.35);
    }

    /* Modal */
    body.modal-open { overflow: hidden; }
    .modal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.6); z-index: 10; opacity: 0; pointer-events: none; transition: opacity .2s ease; }
    .modal.show { opacity: 1; pointer-events: auto; }
    .dialog { width: min(92vw, 460px); background: #0b1220; border: 1px solid #263042; border-radius: 14px; padding: 12px; color: #fff;
      box-shadow: 0 20px 60px rgba(0,0,0,.5); }
    #flappy-canvas { display: block; width: 400px; height: 600px; background: #fff; border-radius: 10px; margin: 0 auto; }

    /* CS image (easter egg trigger) */
    #cs {
      position: fixed; right: 110px; bottom: 0px;
      z-index: 12; transform: scale(0.35); transform-origin: bottom right;
      user-select: none; -webkit-user-drag: none; pointer-events: auto; cursor: default;
    }

    /* +++ Settings button and menu +++ */
    #settingsBtn{
      position: fixed; top: 12px; left: 12px; z-index: 13;
      width: 36px; height: 36px; border-radius: 999px;
      display: flex; align-items: center; justify-content: center;
      background: rgba(0,0,0,.4); border: 1px solid #3a4a5f; color: #fff;
      opacity: .65; cursor: pointer; transition: opacity .15s ease, transform .1s ease;
      pointer-events: auto; padding: 0; line-height: 0;
    }
    #settingsBtn:hover{ opacity: 1; transform: scale(1.04); }
    #settingsBtn svg{ display:block; }

    #settingsMenu{
      position: fixed; top: 56px; left: 12px; z-index: 13;
      width: 260px; padding: 10px 12px; border-radius: 12px;
      background: #0b1220; border: 1px solid #263042; color: #fff;
      box-shadow: 0 12px 40px rgba(0,0,0,.45); display: none;
    }
    #settingsMenu.show{ display: block; }
    #settingsMenu h4{ margin: 4px 0 8px; font-size: 14px; font-weight: 700; color:#cfd8ea; }
    #settingsMenu .row{ display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 8px 0; }
    #settingsMenu input[type="range"]{ width: 100%; }
    #settingsMenu label{ font-size: 13px; color: #c7d2e6; }
    #settingsMenu .val{ font-variant-numeric: tabular-nums; font-size: 13px; color:#fff; }
    #settingsMenu .muted{ opacity:.6 }
  </style>
</head>
<body>

  <!-- +++ Settings: persistent UI +++ -->
  <button id="settingsBtn" aria-label="Settings">
    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <circle cx="12" cy="12" r="3"></circle>
      <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06A2 2 0 1 1 7.04 3.4l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9c0 .66.38 1.26.97 1.54.2.1.41.16.63.16H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1Z"></path>
    </svg>
  </button>
  <div id="settingsMenu" role="dialog" aria-label="Settings">
    <h4>Settings</h4>
    <div class="row">
      <label for="resScale">Resolution scale</label>
      <span id="resScaleVal" class="val">1.00×</span>
    </div>
    <input id="resScale" type="range" min="0.3" max="1" step="0.05">
    <div class="row" style="margin-top:12px">
      <label for="audioVol">Audio volume</label>
      <span id="audioVolVal" class="val muted">—</span>
    </div>
    <input id="audioVol" type="range" min="0" max="1" step="0.01" disabled>
  </div>

  <!-- Background canvases -->
  <canvas id="bg"></canvas>
  <canvas id="canvas"></canvas>

  <!-- Invisible DOM logo (kept for readiness detection) -->
  <img id="logo" alt="Logo" src="logo.png" />
  <!-- CS easter-egg trigger -->
  <img id="cs" alt="CS" src="cs.png" />

  <!-- Flappy mini-game modal -->
  <div id="gameModal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="dialog">
      <canvas id="flappy-canvas" width="400" height="600" aria-label="Flappy game"></canvas>
    </div>
  </div>

  <!-- Bottom form -->
  <form id="form" autocomplete="off">
    <label>
      Player name
      <input id="username" type="text" required autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" />
    </label>

    <div id="cta">
      <div id="progressContainer" aria-label="Loading">
        <svg class="circular" viewBox="0 0 36 36">
          <circle class="bg" cx="18" cy="18" r="16" pathLength="100"></circle>
          <circle id="progressBar" class="bar" cx="18" cy="18" r="16" pathLength="100"></circle>
        </svg>
      </div>
      <button type="submit" id="startBtn">Start</button>
    </div>
  </form>

  <p id="warning">If it's not starting, try to enable microphone and refresh</p>

  <script type="module">
(() => {
  'use strict';

  // ===== Early render-scaler (unchanged) =====
  (function(){
    try{
      var KEY='resScale';
      var saved=parseFloat(localStorage.getItem(KEY) || '1');
      if (!isFinite(saved)) saved = 1;
      saved = Math.min(1, Math.max(0.3, saved));

      if (!window.__renderScaleInstalled){
        window.__renderScaleInstalled = true;
        window.__origDPR = window.devicePixelRatio || 1;
        window.__renderScale = saved;

        try{
          Object.defineProperty(window, 'devicePixelRatio', {
            configurable: true,
            get: function(){ return Math.max(0.25, (window.__origDPR || 1) * (window.__renderScale || 1)); }
          });
        }catch(e){}

        window.__applyRenderScale = function(){
          var cv = document.getElementById('canvas');
          if (!cv) return;
          var rect = cv.getBoundingClientRect();
          var w = Math.max(1, Math.floor(rect.width  * (window.__renderScale || 1)));
          var h = Math.max(1, Math.floor(rect.height * (window.__renderScale || 1)));
          if (cv.width  !== w) cv.width  = w;
          if (cv.height !== h) cv.height = h;
        };

        window.__setRenderScale = function(ns){
          var v = Number(ns);
          if (!isFinite(v)) return;
          v = Math.min(1, Math.max(0.3, v));
          window.__renderScale = v;
          try { localStorage.setItem(KEY, String(v)); } catch(e){}
          window.__applyRenderScale();
          window.dispatchEvent(new Event('resize'));
        };

        var ro = new ResizeObserver(function(){ window.__applyRenderScale(); });
        ro.observe(document.documentElement);
        window.addEventListener('resize', window.__applyRenderScale);
        setTimeout(window.__applyRenderScale, 0);
        setTimeout(window.__applyRenderScale, 250);
        setTimeout(window.__applyRenderScale, 1000);
      }
    }catch(e){}
  })();

  // ===== DOM =====
  const logoEl = document.getElementById('logo');
  const formEl = document.getElementById('form');
  const usernameInput = document.getElementById('username');
  const warningEl = document.getElementById('warning');
  const bgCanvas = document.getElementById('bg');
  const engineCanvas = document.getElementById('canvas');
  const startBtn = document.getElementById('startBtn');
  const csImg = document.getElementById('cs');
  const gameModal = document.getElementById('gameModal');

  // Settings UI wiring
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsMenu = document.getElementById('settingsMenu');
  const resSlider = document.getElementById('resScale');
  const resLabel  = document.getElementById('resScaleVal');
  const audioSlider = document.getElementById('audioVol');
  const audioLabel  = document.getElementById('audioVolVal');

  (function setupSettings(){
    if (!settingsBtn || !settingsMenu) return;

    // open/close
    settingsBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      settingsMenu.classList.toggle('show');
    });
    document.addEventListener('click', (e)=>{
      const t = e.target;
      if (t === settingsBtn || (settingsBtn && settingsBtn.contains(t))) return;
      if (t === settingsMenu || (settingsMenu && settingsMenu.contains(t))) return;
      settingsMenu.classList.remove('show');
    });

    // resolution scale
    if (resSlider && resLabel){
      const KEY='resScale';
      const getSaved = () => {
        const v = parseFloat(localStorage.getItem(KEY) || '1');
        return Math.min(1, Math.max(0.3, isFinite(v) ? v : 1));
      };
      const setLabel = (v) => { resLabel.textContent = v.toFixed(2) + '×'; };
      const initV = getSaved();
      resSlider.value = String(initV);
      setLabel(initV);
      resSlider.addEventListener('input', ()=>{
        const v = Math.min(1, Math.max(0.3, parseFloat(resSlider.value)));
        setLabel(v);
        if (typeof window.__setRenderScale === 'function') window.__setRenderScale(v);
      });
    }

// audio volume
if (audioSlider && audioLabel){
  const KEY='audioVolume';
  const clamp01 = x => Math.min(1, Math.max(0, x));

  const raw = parseFloat(localStorage.getItem(KEY) ?? '1');
  const av  = Number.isFinite(raw) ? clamp01(raw) : 1;   // <-- no "|| 1" here

  audioSlider.value = String(av);
  audioLabel.textContent = Math.round(av*100)+'%';
  audioLabel.classList.remove('muted');
  audioSlider.removeAttribute('disabled');

  audioSlider.addEventListener('input', ()=>{
    const v = clamp01(parseFloat(audioSlider.value));
    audioLabel.textContent = Math.round(v*100)+'%';
    window.__setMasterVolume?.(v);
    try{ localStorage.setItem(KEY, String(v)); }catch(e){}
  });
}

  })();

  // Progress UI (unchanged)
  const progressWrap = document.getElementById('progressContainer');
  const progressBar = document.getElementById('progressBar');
  const progressSvg = progressWrap ? progressWrap.querySelector('svg') : null;

  function showProgressUI(on){
    if (!progressWrap || !startBtn) return;
    progressWrap.hidden = !on;
    startBtn.style.display = on ? 'none' : 'inline-block';
  }
  function setIndeterminate(on){
    if (!progressSvg) return;
    if (on) {
      progressSvg.classList.add('spin');
      if (progressBar) progressBar.style.strokeDashoffset = '75';
    } else {
      progressSvg.classList.remove('spin');
    }
  }
  function setProgressPct(pct){
    if (!progressBar) return;
    const clamped = Math.max(0, Math.min(100, pct));
    progressBar.style.strokeDashoffset = String(100 - clamped);
  }
  showProgressUI(true);
  setIndeterminate(true);

  // ===== Start gating =====
  let canStart = false;
  function lockStart(){ canStart = false; if (startBtn){ startBtn.disabled = true; startBtn.setAttribute('aria-disabled','true'); } }
  function enableStart(){ canStart = true; if (startBtn){ startBtn.disabled = false; startBtn.removeAttribute('aria-disabled'); } }
  lockStart();
  window.addEventListener('pageshow', lockStart);

  // ===== Starfield / waiting game / modal / progress bus / markReady / submit =====

  if (!bgCanvas || !bgCanvas.getContext) { console.warn('#bg canvas missing'); return; }
  const bgCtx = bgCanvas.getContext('2d');
  function resize(){
  // use real DPR, not the scaled one
  const baseDPR = (typeof window.__origDPR === 'number' && window.__origDPR > 0)
    ? window.__origDPR
    : (window.devicePixelRatio || 1);

  bgCanvas.width  = Math.floor(innerWidth  * baseDPR);
  bgCanvas.height = Math.floor(innerHeight * baseDPR);
  bgCtx.setTransform(baseDPR, 0, 0, baseDPR, 0, 0);
}

  addEventListener('resize', resize); resize();
  const stars = Array.from({length:140}, () => ({ x: Math.random()*innerWidth, y: Math.random()*innerHeight, r: Math.random()*1.6+0.2, vx:(Math.random()-0.5)*0.35, vy:(Math.random()-0.5)*0.35 }));
  let bgActive = true;
  function wrap(p){ if(p.x<0)p.x+=innerWidth; if(p.x>innerWidth)p.x-=innerWidth; if(p.y<0)p.y+=innerHeight; if(p.y>innerHeight)p.y-=innerHeight; }

  const logoImg = new Image();
  logoImg.src = (logoEl && logoEl.src) ? logoEl.src : 'logo.png';
  let logoReady = false; logoImg.onload = ()=>{ logoReady = true; };

  const MIN_AREA = 360*640, MAX_AREA = 3840*2160, BRACKETS = 10;
  const edges = Array.from({length: BRACKETS+1}, (_,i)=> MIN_AREA + (i*(MAX_AREA-MIN_AREA))/BRACKETS);
  function bracketIndexFor(area){
    if (area <= edges[0]) return 0;
    if (area >= edges[edges.length-1]) return BRACKETS-1;
    for (let i=0;i<BRACKETS;i++){ if (area >= edges[i] && area < edges[i+1]) return i; }
    return BRACKETS-1;
  }
  function loadHSForBracket(bi){
    const raw = localStorage.getItem('waitingGameHS_b'+bi);
    const n = raw == null ? 0 : parseInt(raw, 10);
    return isNaN(n) ? 0 : n;
  }
  function saveHSForBracket(bi, val){ localStorage.setItem('waitingGameHS_b'+bi, String(val)); }

  const WG = {
    state: 'idle',
    clickCount: 0,
    clicksToSpin: 3,
    clicksToStart: 6,
    hits: 0,
    total: 0,
    duration: 10,
    timeLeft: 0,
    highScore: 0,
    bracket: bracketIndexFor(innerWidth*innerHeight),
  };
  WG.highScore = loadHSForBracket(WG.bracket);

  let engineReady = false;
  let everPlayed = false;
  let lastStats = { hits: 0, total: 0 };

  let mx = innerWidth/2, my = innerHeight/2;
  const SPREAD_BASE = 10, SPREAD_SHOT = 24;
  let spread = SPREAD_BASE, spreadTarget = SPREAD_BASE;
  bgCanvas.addEventListener('mousemove', (e)=>{ const r = bgCanvas.getBoundingClientRect(); mx = e.clientX - r.left; my = e.clientY - r.top; });

  const particles = [];
  function spawnHitBurst(x,y){ for(let i=0;i<12;i++){ const a=Math.random()*Math.PI*2; const v=120+Math.random()*180; particles.push({x,y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, life:0.25, age:0}); } }
  const floaters = [];
  function addFloater(x,y,text,color){ floaters.push({x, y, age:0, life:0.8, text, color}); }

  let lx = innerWidth/2, ly = innerHeight/2;
  let tx = lx, ty = ly;
  let ls = 1, ts = 1;
  let rot = 0;
  let spinning=false, spinT=0;
  let hitSpinT=0;

  function recenterIfCentered(){ if (WG.state==='idle' || WG.state==='spin' || WG.state==='locked'){ const cx=innerWidth/2, cy=innerHeight/2; lx=cx; ly=cy; tx=cx; ty=cy; } }
  addEventListener('resize', recenterIfCentered);
  function center(){ tx=innerWidth/2; ty=innerHeight/2; }

  function randTopZone(){
    const margin=24;
    const maxY=innerHeight*(2/3);
    const base=logoReady ? Math.min(logoImg.naturalWidth, logoImg.naturalHeight) : 160;
    const r=(base*0.5)/2;
    const x=Math.random()*(innerWidth-2*(margin+r))+(margin+r);
    const y=Math.random()*(maxY-2*(margin+r))+(margin+r);
    return [x,y];
  }

  function startRound(){
    if (WG.state==='playing') return;
    if (engineReady){ WG.state='locked'; return; }
    WG.bracket = bracketIndexFor(innerWidth*innerHeight);
    WG.highScore = loadHSForBracket(WG.bracket);
    WG.state='playing';
    WG.hits=0; WG.total=0; WG.timeLeft=WG.duration;
    ts=0.5;
    [tx,ty]=randTopZone();
  }

  bgCanvas.addEventListener('click', (e)=>{
    if (!bgActive) return;
    const rect = bgCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left; const y = e.clientY - rect.top;
    const base = logoReady ? Math.min(logoImg.naturalWidth, logoImg.naturalHeight) : 160;
    const r = (base * ls) / 2; const dx = x - lx, dy = y - ly; const inside = (dx*dx + dy*dy) <= (r*r);

    if (WG.state === 'locked') return;

    if (WG.state === 'idle' || WG.state === 'spin'){
      if (inside){
        WG.clickCount++;
        if (WG.clickCount === WG.clicksToSpin){ spinning = true; spinT = 0; WG.state = 'spin'; }
        else if (WG.clickCount === WG.clicksToStart){ WG.clickCount = 0; startRound(); }
      }
      return;
    }

    if (WG.state === 'playing'){
      WG.total++;
      spreadTarget = SPREAD_SHOT;
      if (inside){
        WG.hits++; hitSpinT = 0;
        WG.timeLeft += 0.5;
        spawnHitBurst(lx,ly);
        addFloater(lx, ly, '+0.5s', '#fff');
        [tx,ty] = randTopZone();
      } else {
        WG.timeLeft = Math.max(0, WG.timeLeft - 0.5);
        addFloater(mx, my, '-0.5s', '#ff6666');
      }
    }
  });

  function openGame(){
    if(!gameModal) return;
    gameModal.classList.add('show');
    document.body.classList.add('modal-open');
    setTimeout(()=>{ if (window.startFlappyBird) window.startFlappyBird('flappy-canvas'); }, 0);
  }
  function closeGame(){
    if(!gameModal) return;
    gameModal.classList.remove('show');
    document.body.classList.remove('modal-open');
  }
  if (gameModal){
    gameModal.addEventListener('click', (e)=>{ if (e.target === gameModal) closeGame(); });
    document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && gameModal.classList.contains('show')) closeGame(); });
  }
  let csClicks = 0;
  if (csImg){
    csImg.addEventListener('click', (e)=>{
      e.stopPropagation();
      csClicks++;
      if (csClicks >= 6){
        csClicks = 0;
        openGame();
      }
    });
  }

  const WEIGHT_DL = 0.5, WEIGHT_UZ = 0.5;
  const prog = {
    dl: { active:false, loaded:0, total:0, pct:null, done:false },
    uz: { active:false, loaded:0, total:0, pct:null, done:false }
  };
  let readyFlag = false;
  function recomputeOverall(){
    if (readyFlag) return;
    const pd = prog.dl.pct; const pu = prog.uz.pct;
    const havePct = (pd != null) || (pu != null);
    if (!havePct){ showProgressUI(true); setIndeterminate(true); return; }
    showProgressUI(true); setIndeterminate(false);
    const pDl = (pd != null) ? pd : (prog.dl.done ? 100 : 0);
    const pUz = (pu != null) ? pu : (prog.uz.done ? 100 : (prog.uz.active ? 0 : 0));
    const overall = WEIGHT_DL * pDl + WEIGHT_UZ * pUz;
    setProgressPct(overall);
  }
  try {
    if ('BroadcastChannel' in window){
      const bc = new BroadcastChannel('dl-progress');
      bc.onmessage = (ev) => {
        const m = ev.data || {};
        if (m.type === 'start'){
          prog.dl.active = true; prog.dl.total = m.total || 0; prog.dl.loaded = m.loaded || 0;
          prog.dl.pct = prog.dl.total ? (prog.dl.loaded / prog.dl.total) * 100 : null;
        } else if (m.type === 'progress'){
          prog.dl.active = true; prog.dl.total = m.total || prog.dl.total; prog.dl.loaded = m.loaded || prog.dl.loaded;
          prog.dl.pct = prog.dl.total ? (prog.dl.loaded / prog.dl.total) * 100 : null;
        } else if (m.type === 'done'){
          prog.dl.done = true; prog.dl.pct = 100;
        } else if (m.type === 'unzip-start'){
          prog.uz.active = true; prog.uz.total = m.totalBytes || 0; prog.uz.loaded = 0; prog.uz.pct = prog.uz.total ? 0 : null;
        } else if (m.type === 'unzip-progress'){
          prog.uz.active = true; prog.uz.total = m.totalBytes || prog.uz.total; prog.uz.loaded = m.loadedBytes ?? prog.uz.loaded;
          prog.uz.pct = prog.uz.total ? (prog.uz.loaded / prog.uz.total) * 100 : null;
        } else if (m.type === 'unzip-done'){
          prog.uz.done = true; prog.uz.pct = 100;
        }
        recomputeOverall();
      };
    }
  } catch {}

  function markReady(){
    if (readyFlag) return;
    readyFlag = true;
    engineReady = true;
    enableStart();
    showProgressUI(false);
    setIndeterminate(false);
    if (WG.state==='idle' || WG.state==='spin'){ WG.state='locked'; ts = 0; }
    closeGame();
  }
  if (logoEl){
    logoEl.addEventListener('animationstart', (e)=>{ if (e.animationName === 'pulsate-end') markReady(); });
    logoEl.addEventListener('animationend',   (e)=>{ if (e.animationName === 'pulsate-end'){ markReady(); logoEl.style.display='none'; } });
    const mo = new MutationObserver(()=>{ const n = logoEl.style.animationName || getComputedStyle(logoEl).animationName; if (n && n.indexOf('pulsate-end')>-1) markReady(); });
    mo.observe(logoEl, { attributes:true, attributeFilter:['style'] });
  }

  formEl?.addEventListener('submit', async (e)=>{
    e.preventDefault();
    if (!canStart) return;
    const name = (usernameInput && usernameInput.value || '').trim();
    if (!name) { usernameInput && usernameInput.focus(); return; }
    formEl.style.display = 'none';
    if (engineCanvas){ engineCanvas.style.opacity='1'; engineCanvas.style.pointerEvents='auto'; }
    if (bgActive){ bgCanvas.style.opacity='0'; setTimeout(()=>{ bgActive=false; bgCanvas.style.display='none'; }, 450); }
    if (csImg){ if(!csImg.style.transition) csImg.style.transition='opacity .3s ease'; csImg.style.opacity='0'; setTimeout(()=>{ csImg.style.display='none'; }, 350); }
    try { const stream = await navigator.mediaDevices.getUserMedia({ audio:true }); stream.getTracks().forEach(t=>t.stop()); warningEl.style.opacity=0; } catch(_) { warningEl.style.opacity=1; }
  });

window.startFlappyBird = function(canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    // Set canvas dimensions.
    canvas.width = 400;
    canvas.height = 600;

    // Load the bird image.    
    const birdImage = new Image(); let imgReady=false; birdImage.onload=()=>{ imgReady=true; start(); }; birdImage.onerror=()=>{ imgReady=false; start(); };
    const logoForBird = document.getElementById('logo'); const birdSrc = (logoForBird && logoForBird.src) ? logoForBird.src : 'logo.png'; birdImage.src = birdSrc;


    // --- Game state ---
    let gameState = "start"; // "start" | "playing" | "gameOver"
    let score = 0;
    let pipes = [];

    // --- Time-based constants (independent of refresh rate) ---
    // These values reproduce the original feel at 60 FPS.
    const FIXED_DT = 1 / 60;           // 60 Hz simulation step (seconds)
    const PIPE_SPEED = 120;            // px/s (was 2 px/frame * 60)
    const PIPE_SPAWN_INTERVAL = 1.5;   // seconds (was 90 frames)
    const SPIN_DURATION = 0.5;         // seconds (was 30 frames)
    const GAME_OVER_LOCKOUT = 1.0;     // seconds (was 60 frames)

    // Pipe geometry.
    const pipeWidth = 60;
    const pipeGap = 150;

    // Time accumulators.
    let timeSinceLastPipe = 0;
    let spinTimerSec = 0;        // counts down
    let gameOverTimerSec = 0;    // counts down

    // Retrieve high score from local storage (or 0 if not set).
    let highScore = parseInt(localStorage.getItem("flappyBirdHighScore") || "0");

// Bird physics (units: px, px/s, px/s^2).
    let bird = {
        x: 50,
        y: 150,
        width: 40,
        height: 40,
        velocity: 0,          // px/s
        gravity: 1800,        // px/s^2  (0.5 px/frame @60fps -> 0.5*60*60)
        jumpForce: -480       // px/s    (-8 px/frame @60fps -> -8*60)
    };

    // --- Helpers ---
    function drawRoundedRect(ctx, x, y, width, height, radius, fillColor, strokeColor) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = strokeColor;
        ctx.stroke();
    }

    function clamp(val, min, max) {
        return Math.max(min, Math.min(val, max));
    }

    function circleRectCollision(cx, cy, radius, rx, ry, rwidth, rheight) {
        const closestX = clamp(cx, rx, rx + rwidth);
        const closestY = clamp(cy, ry, ry + rheight);
        const dx = cx - closestX;
        const dy = cy - closestY;
        return (dx * dx + dy * dy) < (radius * radius);
    }

    // --- Control ---
    function resetGame() {
        bird.y = 150;
        bird.velocity = 0;
        pipes = [];
        score = 0;
        timeSinceLastPipe = 0;
        spinTimerSec = 0;
        gameOverTimerSec = 0;
    }

    function triggerGameOver() {
        if (gameState !== "gameOver") {
            gameState = "gameOver";
            gameOverTimerSec = GAME_OVER_LOCKOUT; // seconds
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("flappyBirdHighScore", highScore);
            }
        }
    }

    // --- Input ---
    canvas.addEventListener("click", function() {
        if (gameState === "start") {
            gameState = "playing";
            resetGame();
        } else if (gameState === "playing") {
            bird.velocity = bird.jumpForce;
        } else if (gameState === "gameOver") {
            if (gameOverTimerSec <= 0) {
                gameState = "playing";
                resetGame();
            }
        }
    });

    document.addEventListener("keydown", function(e) {
        if (e.code === "Space") {
            if (gameState === "start") {
                gameState = "playing";
                resetGame();
            } else if (gameState === "playing") {
                bird.velocity = bird.jumpForce;
            } else if (gameState === "gameOver") {
                if (gameOverTimerSec <= 0) {
                    gameState = "playing";
                    resetGame();
                }
            }
        }
    });

    // --- Update (fixed timestep) ---
    function update(dt) {
        // Timers that tick regardless of "playing".
        if (gameState === "gameOver" && gameOverTimerSec > 0) {
            gameOverTimerSec = Math.max(0, gameOverTimerSec - dt);
        }
        if (spinTimerSec > 0) {
            spinTimerSec = Math.max(0, spinTimerSec - dt);
        }

        if (gameState !== "playing") return;

        // Gravity and movement (time-based).
        bird.velocity += bird.gravity * dt;
        bird.y += bird.velocity * dt;

        // Spawn new pipes on a time interval.
        timeSinceLastPipe += dt;
        while (timeSinceLastPipe >= PIPE_SPAWN_INTERVAL) {
            timeSinceLastPipe -= PIPE_SPAWN_INTERVAL;
            const gapY = Math.random() * (canvas.height - pipeGap - 40) + 20;
            pipes.push({
                x: canvas.width,
                gapY: gapY,
                width: pipeWidth,
                gap: pipeGap,
                passed: false
            });
        }

        // Move pipes and check collisions.
        for (let i = 0; i < pipes.length; i++) {
            let pipe = pipes[i];
            pipe.x -= PIPE_SPEED * dt; // px/s * s = px

            // Award score when the bird passes a pipe.
            if (!pipe.passed && pipe.x + pipe.width < bird.x) {
                score++;
                pipe.passed = true;
                spinTimerSec = SPIN_DURATION;
            }

            // Collision detection using circular hitbox.
            const cx = bird.x + bird.width / 2;
            const cy = bird.y + bird.height / 2;
            const radius = bird.width / 2;
            if (
                circleRectCollision(cx, cy, radius, pipe.x, 0, pipe.width, pipe.gapY) ||
                circleRectCollision(cx, cy, radius, pipe.x, pipe.gapY + pipe.gap, pipe.width, canvas.height - (pipe.gapY + pipe.gap))
            ) {
                triggerGameOver();
            }
        }

        // Remove off-screen pipes.
        pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);

        // Check boundaries.
        if (bird.y + bird.height > canvas.height || bird.y < 0) {
            triggerGameOver();
        }
    }

    // --- Draw ---
    function draw() {
        // Clear background.
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw pipes if playing or game over.
        if (gameState === "playing" || gameState === "gameOver") {
            ctx.fillStyle = "#1B3F5A";
            pipes.forEach(pipe => {
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.gapY);
                ctx.fillRect(pipe.x, pipe.gapY + pipe.gap, pipe.width, canvas.height - (pipe.gapY + pipe.gap));
            });
        }

        // Bird rotation based on spin progress.
        ctx.save();
        let angle = 0;
        if (spinTimerSec > 0) {
            const progress = 1 - (spinTimerSec / SPIN_DURATION); // 0 â†’ 1
            angle = progress * 2 * Math.PI;
        }
        ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
        ctx.beginPath();
        ctx.arc(0, 0, bird.width / 2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();
        ctx.rotate(-angle);
        ctx.drawImage(birdImage, -bird.width / 2, -bird.height / 2, bird.width, bird.height);
        ctx.restore();

        // UI: Score + High Score (upper-left).
        ctx.font = "20px Arial";
        ctx.textAlign = "left";
        let padding = 4;
        let scoreText = "Score: " + score;
        let highScoreText = "High Score: " + highScore;
        let scoreWidth = ctx.measureText(scoreText).width;
        let highScoreWidth = ctx.measureText(highScoreText).width;
        let boxWidth = Math.max(scoreWidth, highScoreWidth) + padding * 2;
        let boxHeight = 50;
        drawRoundedRect(ctx, 5, 5, boxWidth, boxHeight, 8, "white", "#1B3F5A");
        ctx.fillStyle = "#1B3F5A";
        ctx.fillText(scoreText, 5 + padding, 25);
        ctx.fillText(highScoreText, 5 + padding, 45);

        // Start screen.
        if (gameState === "start") {
            ctx.font = "24px Arial";
            ctx.textAlign = "center";
            let line1 = "Press Space";
            let line2 = "or Click to Start";
            padding = 10;
            let line1Width = ctx.measureText(line1).width;
            let line2Width = ctx.measureText(line2).width;
            boxWidth = Math.max(line1Width, line2Width) + padding * 2;
            boxHeight = 70;
            let boxX = (canvas.width - boxWidth) / 2;
            let boxY = canvas.height / 2 - boxHeight / 2;
            drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, 8, "white", "#1B3F5A");
            ctx.fillStyle = "#1B3F5A";
            ctx.fillText(line1, canvas.width / 2, boxY + 30);
            ctx.fillText(line2, canvas.width / 2, boxY + 55);
        }
        // Game over box.
        else if (gameState === "gameOver") {
            let gameOverLine = "Game Over";
            let scoreLine = "Score: " + score;
            let restartLine = "Click or Press Space to Restart";
            padding = 10;
            ctx.font = "40px Arial";
            ctx.textAlign = "center";
            let gameOverWidth = ctx.measureText(gameOverLine).width;
            ctx.font = "24px Arial";
            let scoreWidthGO = ctx.measureText(scoreLine).width;
            let restartWidth = ctx.measureText(restartLine).width;
            boxWidth = Math.max(gameOverWidth, scoreWidthGO, restartWidth) + padding * 2;
            boxHeight = 150;
            let boxX = (canvas.width - boxWidth) / 2;
            let boxY = canvas.height / 2 - boxHeight / 2;
            drawRoundedRect(ctx, boxX, boxY, boxWidth, boxHeight, 8, "white", "#1B3F5A");

            ctx.fillStyle = "#1B3F5A";
            ctx.font = "40px Arial";
            ctx.fillText(gameOverLine, canvas.width / 2, boxY + 45);
            ctx.font = "24px Arial";
            ctx.fillText(scoreLine, canvas.width / 2, boxY + 80);
            if (gameOverTimerSec <= 0) {
                ctx.font = "20px Arial";
                ctx.fillText(restartLine, canvas.width / 2, boxY + 120);
            }
        }
    }

    // --- Main loop: fixed 60 Hz updates, RAF-driven rendering ---
    let lastTime = null;     // seconds
    let accumulator = 0;     // seconds

    function gameLoop(nowMs) {
        const now = nowMs / 1000;
        if (lastTime === null) lastTime = now;
        let delta = now - lastTime;

        // Avoid huge catch-up steps if tab was backgrounded.
        if (delta > 0.25) delta = 0.25;

        lastTime = now;
        accumulator += delta;

        // Run the simulation at a fixed 60 Hz, regardless of RAF rate.
        while (accumulator >= FIXED_DT) {
            update(FIXED_DT);
            accumulator -= FIXED_DT;
        }

        draw();
        requestAnimationFrame(gameLoop);
    }

    // Start the loop once the image is loaded.
    birdImage.onload = function() {
        requestAnimationFrame(gameLoop);
    };
};


  // ===== Main RAF =====
  let lastT = performance.now();
  function loop(t){
    if (!bgActive) return;
    const dt = Math.min(0.05, (t - lastT)/1000);
    lastT = t;
    const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand').trim()||'#1B3F5A';
    bgCtx.fillStyle = brand;
    bgCtx.fillRect(0,0,innerWidth,innerHeight);
    bgCtx.globalAlpha=0.95; bgCtx.beginPath();
    for(const s of stars){ s.x+=s.vx; s.y+=s.vy; wrap(s); bgCtx.moveTo(s.x,s.y); bgCtx.arc(s.x,s.y,s.r,0,Math.PI*2); }
    bgCtx.fillStyle='#fff'; bgCtx.fill(); bgCtx.globalAlpha=1;

    updateWaiting(dt);
    drawWaiting();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function updateWaiting(dt){
    bgCanvas.style.cursor = (WG.state==='playing') ? 'none' : 'auto';

    const speed = 1800; const dx = tx - lx, dy = ty - ly; const dist = Math.hypot(dx, dy);
    if (dist > 0.5) { const step = Math.min(dist, speed * dt); const k = step / dist; lx += dx * k; ly += dy * k; } else { lx = tx; ly = ty; }

    if (WG.state === 'playing') { ts = (dist > 1) ? 0.25 : 0.5; }
    else if (WG.state === 'locked') { ts = 0; }
    else { ts = 1; }

    const scaleSpeed = 6; const ds = ts - ls; if (Math.abs(ds) > 0.001) { ls += Math.sign(ds) * Math.min(Math.abs(ds), scaleSpeed * dt); }

    if (spinning){
      const dur=0.7; spinT += dt; const p=Math.min(spinT/dur,1);
      rot = -2*Math.PI*p;
      if (p>=1){ spinning=false; rot=0; if (WG.state==='spin') WG.state='idle'; }
    }

    if (hitSpinT < 0.3){
      hitSpinT += dt; const hp = Math.min(hitSpinT/0.3, 1);
      rot = -4*Math.PI*hp;
      if (hp>=1 && !spinning) rot=0;
    }

    for (let i=particles.length-1; i>=0; i--){
      const p=particles[i]; p.age+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
      if (p.age>=p.life) particles.splice(i,1);
    }

    for (let i=floaters.length-1; i>=0; i--){
      const f=floaters[i]; f.age += dt; f.y -= 40*dt;
      if (f.age >= f.life) floaters.splice(i,1);
    }

    spread += (spreadTarget - spread) * Math.min(1, dt*12);
    spreadTarget += (SPREAD_BASE - spreadTarget) * Math.min(1, dt*6);

    if (WG.state==='playing'){
      WG.timeLeft -= dt;
      if (WG.timeLeft <= 0){
        WG.state = 'idle';
        center();
        everPlayed = true; lastStats.hits = WG.hits; lastStats.total = WG.total;
        if (WG.hits > WG.highScore) {
          WG.highScore = WG.hits;
          saveHSForBracket(WG.bracket, WG.highScore);
        }
        if (engineReady) { WG.state='locked'; ts = 0; }
      }
    }
  }

  function drawWaiting(){
    if (!logoReady) return;

    if (WG.state === 'playing') {
      const tDisp = '⏱ ' + Math.max(0, WG.timeLeft).toFixed(1) + 's';
      bgCtx.save();
      bgCtx.font = 'bold 34px Arial';
      bgCtx.textAlign = 'center';
      bgCtx.fillStyle = '#fff';
      bgCtx.fillText(tDisp, innerWidth / 2, 40);
      bgCtx.restore();
    }

    const base = Math.min(logoImg.naturalWidth||160, logoImg.naturalHeight||160);
    const size = base * ls; const half = size/2;
    bgCtx.save();
    bgCtx.translate(lx, ly);
    bgCtx.rotate(rot);
    bgCtx.beginPath();
    bgCtx.arc(0,0,half,0,Math.PI*2);
    bgCtx.clip();
    bgCtx.drawImage(logoImg, -half, -half, size, size);
    bgCtx.restore();

    if (particles.length){
      bgCtx.save();
      bgCtx.fillStyle='#fff';
      for (const p of particles){
        const a = Math.max(0, 1 - p.age/p.life);
        bgCtx.globalAlpha = a;
        bgCtx.beginPath();
        bgCtx.arc(p.x,p.y, 1 + (1-a)*1, 0, Math.PI*2);
        bgCtx.fill();
      }
      bgCtx.globalAlpha=1;
      bgCtx.restore();
    }

    if (floaters.length){
      bgCtx.save();
      bgCtx.font = 'bold 14px Arial';
      for (const f of floaters){
        const a = Math.max(0, 1 - f.age / f.life);
        if (a <= 0) continue;
        bgCtx.globalAlpha = a;
        bgCtx.fillStyle = f.color || '#fff';
        bgCtx.fillText(f.text, f.x + 18, f.y - 10 - (1 - a) * 20);
      }
      bgCtx.globalAlpha = 1;
      bgCtx.restore();
    }

    if (WG.state === 'playing' || everPlayed) {
      const hitsDisp = (WG.state === 'playing') ? WG.hits : lastStats.hits;
      const totalDisp = (WG.state === 'playing') ? WG.total : Math.max(1, lastStats.total);
      const acc = Math.round((hitsDisp / totalDisp) * 100);
      const hud = (WG.state === 'playing')
        ? `Hits ${hitsDisp}  •  Acc ${acc}%  •  Best ${WG.highScore}`
        : `Best ${WG.highScore}  •  Last ${hitsDisp} hits  •  Acc ${acc}%`;
      bgCtx.font = '16px Arial';
      bgCtx.textAlign = 'right';
      bgCtx.fillStyle = '#fff';
      bgCtx.fillText(hud, innerWidth - 12, 24);
    }

    if (WG.state === 'playing'){
      bgCtx.save();
      bgCtx.translate(mx, my);
      const g=spread; const len=12;

      // outline
      bgCtx.lineWidth=4; bgCtx.strokeStyle='#000'; bgCtx.beginPath();
      bgCtx.moveTo(-g-len,0); bgCtx.lineTo(-g,0);
      bgCtx.moveTo(g,0); bgCtx.lineTo(g+len,0);
      bgCtx.moveTo(0,-g-len); bgCtx.lineTo(0,-g);
      bgCtx.moveTo(0,g); bgCtx.lineTo(0,g+len);
      bgCtx.stroke();

      // white inner
      bgCtx.lineWidth=2; bgCtx.strokeStyle='#fff'; bgCtx.beginPath();
      bgCtx.moveTo(-g-len,0); bgCtx.lineTo(-g,0);
      bgCtx.moveTo(g,0); bgCtx.lineTo(g+len,0);
      bgCtx.moveTo(0,-g-len); bgCtx.lineTo(0,-g);
      bgCtx.moveTo(0,g); bgCtx.lineTo(0,g+len);
      bgCtx.stroke();

      bgCtx.restore();
    }
  }

  try {
    console.assert(bgCanvas, '#bg exists');
    console.assert(engineCanvas, '#canvas exists');
    console.assert(getComputedStyle(engineCanvas).opacity === '0', '#canvas hidden until Start');
  } catch(e) { console.warn('Self-tests warning:', e); }
})();
</script>
</body>
</html>
